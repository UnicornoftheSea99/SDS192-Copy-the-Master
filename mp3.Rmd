---
title: "Put a real title here"
subtitle: "SDS 192: MP3"
author: 
- name: Emily Rhyu
  affiliation: Smith College
- name: Julia Walker
  affiliation: Smith College
date: "`r format(Sys.Date(), '%B %e, %Y')`"
output: 
  html_document:
    toc: true
    toc_depth: 2
    toc_float: true
    fig_width: 10
    fig_height: 6
    fig_caption: true
    theme: lumen
    df_print: paged
    code_folding: show
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  message = FALSE,
  echo = TRUE,
  warning = FALSE
)
library(tidyverse)
library(sds192)
library(babynames)
library(purrr)
library(dplyr)
library(tidyr)
library(ggplot2)
```

## Instructions

> READ THE INSTRUCTIONS: https://beanumber.github.io/sds192/mod_babynames.html

Your goal in Step 1 is to recreate this data graphic as closely as you can:

![](https://beanumber.github.io/sds192/gfx/jessie.png)

## Step 1: Make the plot for "Jessie"

### Step 1A: Gather the data for "Jessie"

```{r jessie-data}
jessie <- babynames %>%
  filter(
    name == "Jessie", 
    year >= 1930 & year < 2012
  ) %>%
  select(-prop) %>%
  pivot_wider(names_from = sex, values_from = n) %>%
  mutate(pct_girls = F / (F + M))
jessie
```

### Step 1B: Compute the "most unisex year"

```{r jessie-year}
jessie_unisex_year <- jessie %>%
  mutate(distance = abs(pct_girls - 0.5)) %>%
  arrange(distance) %>%
  head(1)
jessie_unisex_year
```


### Step 1C: Add the annotations for "Jessie"

```{r jessie-context}
jessie_context <- tribble(
  ~year_label, ~vpos, ~hjust, ~name, ~text,
  1934, 0.35, "left", "Jessie", "Most\nunisex year"
)

jessie_segments <- tribble(
  ~year, ~pct_girls, ~name,
  1940, 0.43, "Jessie",
  1940, 0.5, "Jessie",
  1949, 0.4956897, "Jessie"
)

jessie_labels <- tribble(
  ~year, ~name, ~pct_girls, ~label,
  1998, "Jessie", 0.8, "BOYS",
  1998, "Jessie", 0.2, "GIRLS"
)
```

### Step 1D: Draw the plot for "Jessie"

```{r jessie-plot}
ggplot(jessie, aes(x = year, y = pct_girls)) +
  geom_line() +
  geom_area(fill = "#eaac9e") +
  geom_point(data = jessie_unisex_year, fill = "white", pch = 21, size = 3) +
  geom_path(data = jessie_segments) +
  geom_text(
    data = jessie_labels, 
    aes(label = label), 
    color = "white"
  ) +
  geom_text(
    data = jessie_context, family = "Century Gothic",
    aes(x = year_label, y = vpos, label = text, hjust = hjust), vjust = "top"
  ) +
  scale_y_continuous(NULL, 
    limits = c(0, 1),
    breaks = c(0, 0.5, 1),
    labels = scales::percent
  ) +
  scale_x_continuous(breaks = c(1940, 1960, 1980, 2000), labels = c("1940", "'60", "'80", "2000"), NULL) +
  scale_fill_manual(values = c("#eaac9e", "black")) +
  theme(
    panel.background = element_rect(fill = "#92bdd3"),
    axis.ticks.y = element_blank(),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    text = element_text(family = "Century Gothic"),
    strip.background = element_blank(),
    strip.text = element_text(hjust = 0, face = "bold", size = 14)
  ) +
  guides(fill = FALSE) +
  labs(
    title = "1. Jessie", 
    caption = "Source: Social Security Administration | By http://flowingdata.com"
  )
```

## Step 2: Make the graphic for all 35 names

Make [the full data graphic](https://i2.wp.com/flowingdata.com/wp-content/uploads/2013/09/most-unisex-names2.png?w=2000) with the 35 most gender-neutral names:

![](https://i2.wp.com/flowingdata.com/wp-content/uploads/2013/09/most-unisex-names2.png?w=2000)

Or at least, make an attempt that's as good as mine:

![](https://beanumber.github.io/sds192/gfx/my_babynames.png)

> Note: Please do **NOT** obsess about making this perfect. It probably can't be done! Just give it your best shot!

This bit of code will create a data frame with the 35 names as ranked by FlowingData.com. You can use this to check your work, but note that to meet the standard for *computing* the names, you need to discover these names algorithmically. 

```{r}
fd_names <- c(
  "Jessie", "Marion", "Jackie", "Alva", "Ollie",
  "Jody", "Cleo", "Kerry", "Frankie", "Guadalupe",
  "Carey", "Tommie", "Angel", "Hollis", "Sammie",
  "Jamie", "Kris", "Robbie", "Tracy", "Merrill",
  "Noel", "Rene", "Johnnie", "Ariel", "Jan",
  "Devon", "Cruz", "Michel", "Gale", "Robin",
  "Dorian", "Casey", "Dana", "Kim", "Shannon"
) %>%
  enframe(name = "fd_rank", value = "name")
```

### Step 2A: Compute the RMSE for Jessie

```{r}
jessie %>%
  mutate(
    error = pct_girls - 0.5,
    squared_error = error^2
  ) %>%
  summarize(
    mse = mean(squared_error),
    rmse = sqrt(mse)
  )
```

### Step 2B: Compute the RMSE for all names

```{r}
#collect all baby data, filter and reshape it
all_babies <- babynames %>%
  filter( year >= 1930 & year < 2012) %>%
  select(-prop) %>%
  pivot_wider(names_from = sex, values_from = n) %>%
   mutate(

    #F = replace_na(F,0),
    #M = replace_na(M,0), 
  pct_girls = F / (F + M)

   )%>%
  #filter(!is.na(F), !is.na(M)) 
  #filter(!is.na(F) | !is.na(M))
  filter(!is.na(F) & !is.na(M)) 

# something is weird w/ the way we filtered out NAs, because  I found some in stuff we created later
  
```

```{r}
rmse <- function(x) {
  x %>%
    mutate(
           error = pct_girls - 0.5,
           squared_error = error^2
    ) %>%
    summarize(
      mse = mean(squared_error),
      rmse = sqrt(mse)
    )
}

# try to use function on fewer names 
# trial_names <- babynames %>%
#   filter(name == "Jessie" | name == "Marion" | name == "Jackie")

# trial_names %>%
#   filter( year >= 1930 & year < 2012) %>%
#   select(-prop) %>%
#   pivot_wider(names_from = sex, values_from = n) %>%
#   group_by(name) %>%
#   group_modify(~rmse(.x))

# try entire data set - taking forever but might work?
# babynames %>%
#   filter( year >= 1930 & year < 2012) %>%
#   select(-prop) %>%
#   pivot_wider(names_from = sex, values_from = n) %>%
#   group_by(name) %>%
#   group_modify(~rmse(.x))


  
```

```{r, eval=FALSE}
all_babies %>%
  group_by(name)%>%
  group_modify(~rmse(.x))
```


### Step 2C: Rank and filter the list of names
```{r}
#finds 1000 most popular names
popular_names <- all_babies %>%
  #filter(pct_girls>=0.25, pct_girls<=0.75)%>%
  group_by(name)%>%
  summarize(
    #avg_pct_girls = mean(pct_girls),
    total_years = n(),
    total_occurences = sum(F+M)
  ) %>%
  filter(total_years >= 70) %>%
  #filter(avg_pct_girls>=0.3, avg_pct_girls<=0.7) #%>%
  arrange(desc(total_occurences))%>%
 head(1000)

pop_rmse <- all_babies%>%
  inner_join(popular_names, by = "name")




most_unisex_names <- pop_rmse %>%
#  head(1000)%>%
  group_by(name)%>%
  group_modify(~rmse(.x))%>%
  arrange((rmse))%>%
 head(35)
```


### Step 2D: Gather the data you need to draw the time series
```{r, eval = FALSE}
# use pipeline from step 1A and join to our top unisex names 
data <- babynames %>%
  filter(
    year >= 1930 & year < 2012
  ) %>%
  select(-prop) %>%
  pivot_wider(names_from = sex, values_from = n) %>%
  mutate(pct_girls = F / (F + M)) %>%
  inner_join(most_unisex_names, by = c("name" = "name"))
dim(data)

# dimensions not 35n, probably because some names are missing in certain years?
```

```{r, eval = FALSE}
# write a function to compute RMSE
rmse_all <- function(name_arg) {
  all_babies %>%
    filter(name == name_arg) %>%
     mutate(
       pct_girls = F / (F + M),
       error = pct_girls - 0.5,
       squared_error = error^2) %>%
  summarize(
    mse = mean(squared_error),
    rmse = sqrt(mse)
  )
}

#CHECKING THAT IT WORKS, IT DOES!!
#rmse_all("Jessie")

# map(c(
#   "Jessie", "Marion", "Jackie", "Alva", "Ollie",
#   "Jody", "Cleo", "Kerry", "Frankie", "Guadalupe",
#   "Carey", "Tommie", "Angel", "Hollis", "Sammie",
#   "Jamie", "Kris", "Robbie", "Tracy", "Merrill",
#   "Noel", "Rene", "Johnnie", "Ariel", "Jan",
#   "Devon", "Cruz", "Michel", "Gale", "Robin",
#   "Dorian", "Casey", "Dana", "Kim", "Shannon"
# ), rmse_all)

#will use map_dfr to apply to all names
```

### Step 2E: Gather the data you need to draw the points
Goal: generalize the pattern you used in Step 1B to compute the most unisex year for each of the 35 names. Again, you can do this by either mapping a function or by joining.

should end up with a data frame with 35 rows.

```{r}
# write a function
most_unisex_yr <- function(name_arg) {
  all_babies %>%
    filter(name == name_arg) %>%
    mutate(distance = abs(pct_girls - 0.5)) %>%
    arrange(distance) %>%
    head(1)
}

# use it
names_list <- most_unisex_names %>% 
  select(-mse, -rmse) %>%
  deframe()
unisex_years <- map_dfr(names_list, most_unisex_yr)
```


Step 2F: Polish the data
### Step 2F: Polish the data

### Step 2G: Create the annotations
-  need labels for Marion, Jackie, Ariel, Jamie
-  as of now only Marion is in our filtered list of names
```{r}

```


> Hint: Read [the section in the book about customizing **gplot2** graphics](https://mdsr-book.github.io/mdsr2e/ch-vizIII.html#sec:themes)

### Step 2H: Order the facets

```{r}
#all ranks 1,  convert rmse to a factor first? 
#most_unisex_names <- most_unisex_names %>%
  #mutate(name_rank = dense_rank(rmse))

```

### Step 2I: Draw the plot

definitely not finished yet!

```{r}
ggplot(data, aes(x = year, y = pct_girls)) +
  geom_line() +
  geom_area(fill = "#eaac9e") +
  facet_wrap(~name) +
  geom_point(data = unisex_years, fill = "white", pch = 21, size = 3) +
  geom_path(data = jessie_segments) +
  geom_text(
    data = jessie_labels, 
    aes(label = label), 
    color = "white"
  ) +
  geom_text(
    data = jessie_context, family = "Century Gothic",
    aes(x = year_label, y = vpos, label = text, hjust = hjust), vjust = "top"
  ) +
  scale_y_continuous(NULL, 
    limits = c(0, 1),
    breaks = c(0, 0.5, 1),
    labels = scales::percent
  ) +
  scale_x_continuous(breaks = c(1940, 1960, 1980, 2000), labels = c("1940", "'60", "'80", "2000"), NULL) +
  scale_fill_manual(values = c("#eaac9e", "black")) +
  theme(
    panel.background = element_rect(fill = "#92bdd3"),
    axis.ticks.y = element_blank(),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    text = element_text(family = "Century Gothic"),
    strip.background = element_blank(),
    strip.text = element_text(hjust = 0, face = "bold", size = 14)
  ) +
  guides(fill = FALSE) +
  labs(
    title = "1. Jessie", 
    caption = "Source: Social Security Administration | By http://flowingdata.com"
  )
```


## Word count

```{r word_count, message=FALSE, echo=FALSE}
text_stats()
```

## Standards

In this assignment, we attempted the following [standards](https://beanumber.github.io/sds192/standards.html):

- `r standard_button("wrangling")`: We met the Wrangling standard because we...
- `r standard_button("relational")`: We met the Relational standard because we...
- `r standard_button("reshape")`: We met the Reshape standard because we...
- `r standard_button("aesthetics")`: We mastered the Aesthetics standard because we...
- `r standard_button("markdown")`: We mastered the R Markdown standard because we...

## References